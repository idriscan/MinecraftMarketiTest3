<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Healing Heart</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;1,400&display=swap');

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none; /* Prevent text selection during drag */
        }

        body {
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        /* Canvas covers the whole screen */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Text Container */
        .message-container {
            position: absolute;
            bottom: 15%; /* Positioned below center */
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 0; /* Behind canvas interaction layer if needed, but visually consistent */
            pointer-events: none; /* Let clicks pass through to canvas */
            padding: 0 20px;
        }

        .message-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            max-width: 600px;
            margin: 0 auto;
            font-style: italic;
        }

        /* UI Controls */
        #ui-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
        }

        #ui-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #settings-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            overflow-y: auto;
            max-height: 80vh;
        }

        #settings-panel.active {
            transform: translateX(0);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        input[type="color"] {
            border: none;
            width: 100%;
            height: 35px;
            cursor: pointer;
            background: none;
        }

        select {
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
        }

        .hidden {
            display: none;
        }

        h3 {
            margin-bottom: 15px;
            font-weight: normal;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .message-text {
                font-size: 1rem;
            }
            #settings-panel {
                width: 90%;
                right: 5%;
            }
        }
    </style>
</head>
<body>

    <button id="ui-toggle" title="Settings">⚙️</button>

    <div id="settings-panel">
        <h3>Settings</h3>
        
        <div class="control-group">
            <label>Particle Color</label>
            <input type="color" id="particleColor" value="#ff4d6d">
        </div>

        <div class="control-group">
            <label>Trail Color</label>
            <input type="color" id="trailColor" value="#ffffff">
        </div>

        <div class="control-group">
            <label>Number of Particles: <span id="pCountVal">800</span></label>
            <input type="range" id="particleCount" min="200" max="2000" value="800">
        </div>

        <div class="control-group">
            <label>Trail Length: <span id="tLengthVal">20</span></label>
            <input type="range" id="trailLength" min="0" max="50" value="20">
        </div>

        <hr style="border: 0; border-top: 1px solid #444; margin: 15px 0;">

        <div class="control-group">
            <label>Background Style</label>
            <select id="bgStyle">
                <option value="solid">Solid Color</option>
                <option value="gradient">Gradient</option>
                <option value="grid">Grid Pattern</option>
            </select>
        </div>

        <div class="control-group" id="bg-color-1-group">
            <label>Background Color 1</label>
            <input type="color" id="bgColor1" value="#111111">
        </div>

        <div class="control-group hidden" id="bg-color-2-group">
            <label>Background Color 2 (Gradient)</label>
            <input type="color" id="bgColor2" value="#2d1b2e">
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="message-container">
        <p class="message-text">
            "İlişkimiz bu kalp ve dokununca hasar alıyor ama her zaman hala sağlam kalabiliyor ne kadar zaman geçerse geçsin hep sağlam kalacak"
        </p>
    </div>

    <script>
        /**
         * CONFIGURATION & STATE
         */
        const config = {
            particleColor: '#ff4d6d',
            trailColor: '#ffffff',
            particleCount: 800,
            trailLength: 20,
            bgStyle: 'solid',
            bgColor1: '#111111',
            bgColor2: '#2d1b2e',
            repulsionRadius: 100,
            repulsionForce: 15,
            returnSpeed: 0.05, // Lower is smoother/slower healing
            heartScale: 15     // Multiplier for heart math
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width, height, centerX, centerY;
        let particles = [];
        let trail = []; // {x, y, opacity}
        
        // Mouse/Touch State
        const pointer = {
            x: -1000,
            y: -1000,
            isDown: false
        };

        /**
         * INITIALIZATION
         */
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2 - 50; // Shift slightly up to make room for text
            initParticles();
        }

        window.addEventListener('resize', resize);

        /**
         * MATH HELPERS
         */
        // Standard Heart Formula: (x^2 + y^2 - 1)^3 - x^2*y^3 <= 0
        function isInsideHeart(x, y) {
            // Normalize scale for checking
            const s = config.heartScale;
            x /= s;
            y /= s;
            y = -y; // Flip Y because canvas Y is down

            // Optimization for top dimple smoothing
            const a = x * x + y * y - 1;
            return (a * a * a - x * x * y * y * y) <= 0;
        }

        /**
         * PARTICLE CLASS
         */
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                // Rejection sampling to find a point inside the heart
                let found = false;
                let limit = 0;
                while (!found && limit < 1000) {
                    // Random point in a bounding box approx around center
                    const range = config.heartScale * 3.5;
                    const rx = (Math.random() - 0.5) * range;
                    const ry = (Math.random() - 0.5) * range;
                    
                    if (isInsideHeart(rx, ry)) {
                        this.originX = centerX + rx * 12; // Spread factor
                        this.originY = centerY + ry * 12;
                        this.x = this.originX;
                        this.y = this.originY;
                        found = true;
                    }
                    limit++;
                }
                if(!found) {
                    // Fallback to center if math fails heavily
                    this.originX = centerX;
                    this.originY = centerY;
                    this.x = centerX;
                    this.y = centerY;
                }
                
                this.size = Math.random() * 2 + 1;
                this.vx = 0;
                this.vy = 0;
            }

            update() {
                // 1. Calculate distance to pointer
                const dx = this.x - pointer.x;
                const dy = this.y - pointer.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // 2. Repulsion (Anti-gravity)
                if (pointer.isDown && dist < config.repulsionRadius) {
                    const force = (config.repulsionRadius - dist) / config.repulsionRadius;
                    const angle = Math.atan2(dy, dx);
                    
                    this.vx += Math.cos(angle) * force * config.repulsionForce;
                    this.vy += Math.sin(angle) * force * config.repulsionForce;
                }

                // 3. Restoration (Healing) - Spring physics / Linear interpolation
                // Move towards origin
                this.x += (this.originX - this.x) * config.returnSpeed;
                this.y += (this.originY - this.y) * config.returnSpeed;

                // Apply velocity from repulsion
                this.x += this.vx;
                this.y += this.vy;

                // Friction to stop them flying away forever
                this.vx *= 0.9;
                this.vy *= 0.9;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles() {
            particles = [];
            for (let i = 0; i < config.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        /**
         * INTERACTION HANDLERS
         */
        function handlePointerMove(x, y) {
            pointer.x = x;
            pointer.y = y;

            // Add to trail
            if (config.trailLength > 0) {
                trail.push({ x: x, y: y, life: 1.0 });
                if (trail.length > config.trailLength) {
                    trail.shift();
                }
            }
        }

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            pointer.isDown = true;
            handlePointerMove(e.clientX, e.clientY);
        });
        window.addEventListener('mouseup', () => pointer.isDown = false);
        window.addEventListener('mousemove', (e) => {
            if(pointer.isDown) handlePointerMove(e.clientX, e.clientY);
            else {
                // Track mouse for trail even if not dragging
                pointer.x = e.clientX;
                pointer.y = e.clientY;
                handlePointerMove(e.clientX, e.clientY);
            }
        });

        // Touch Events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            pointer.isDown = true;
            handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        window.addEventListener('touchend', () => pointer.isDown = false);
        
        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});


        /**
         * DRAWING FUNCTIONS
         */
        function drawBackground() {
            if (config.bgStyle === 'solid') {
                ctx.fillStyle = config.bgColor1;
                ctx.fillRect(0, 0, width, height);
            } else if (config.bgStyle === 'gradient') {
                const grad = ctx.createLinearGradient(0, 0, width, height);
                grad.addColorStop(0, config.bgColor1);
                grad.addColorStop(1, config.bgColor2);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);
            } else if (config.bgStyle === 'grid') {
                ctx.fillStyle = config.bgColor1;
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                const gridSize = 40;
                
                ctx.beginPath();
                for (let x = 0; x <= width; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                for (let y = 0; y <= height; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                ctx.stroke();
            }
        }

        function drawTrail() {
            if (trail.length < 2) return;
            
            ctx.beginPath();
            ctx.strokeStyle = config.trailColor;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw segments with fading opacity
            for (let i = 0; i < trail.length - 1; i++) {
                const point = trail[i];
                const nextPoint = trail[i+1];
                
                // Calculate opacity based on index/life
                const opacity = (i / trail.length); 
                ctx.globalAlpha = opacity;
                ctx.lineWidth = opacity * 5; 
                
                ctx.beginPath();
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(nextPoint.x, nextPoint.y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
        }

        /**
         * ANIMATION LOOP
         */
        function animate() {
            // Draw Background
            drawBackground();

            // Draw Trail
            drawTrail();

            // Draw Particles
            ctx.fillStyle = config.particleColor;
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        /**
         * UI LOGIC
         */
        const toggleBtn = document.getElementById('ui-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        
        toggleBtn.addEventListener('click', () => {
            settingsPanel.classList.toggle('active');
        });

        // Event Listeners for Controls
        document.getElementById('particleColor').addEventListener('input', (e) => config.particleColor = e.target.value);
        document.getElementById('trailColor').addEventListener('input', (e) => config.trailColor = e.target.value);
        
        document.getElementById('particleCount').addEventListener('input', (e) => {
            config.particleCount = parseInt(e.target.value);
            document.getElementById('pCountVal').innerText = config.particleCount;
            initParticles(); // Re-init on change
        });

        document.getElementById('trailLength').addEventListener('input', (e) => {
            config.trailLength = parseInt(e.target.value);
            document.getElementById('tLengthVal').innerText = config.trailLength;
            // Trim trail immediately if shortened
            if(trail.length > config.trailLength) trail = trail.slice(trail.length - config.trailLength);
        });

        document.getElementById('bgStyle').addEventListener('change', (e) => {
            config.bgStyle = e.target.value;
            const group2 = document.getElementById('bg-color-2-group');
            if (config.bgStyle === 'gradient') {
                group2.classList.remove('hidden');
            } else {
                group2.classList.add('hidden');
            }
        });

        document.getElementById('bgColor1').addEventListener('input', (e) => config.bgColor1 = e.target.value);
        document.getElementById('bgColor2').addEventListener('input', (e) => config.bgColor2 = e.target.value);

        // START
        resize();
        animate();

    </script>
</body>
</html>
